name: Deploy to Azure Container Apps

on:
  push:
    branches: [ '**' ]  # Deploy any branch
  workflow_dispatch:

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  AZURE_RESOURCE_GROUP: aks-gh-tool
  AZURE_LOCATION: northeurope

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Set branch-specific variables
      id: branch-vars
      run: |
        # Sanitize branch name for Azure resource naming (alphanumeric and hyphens only, max 60 chars)
        BRANCH_NAME="${{ github.ref_name }}"
        SANITIZED_BRANCH=$(echo "$BRANCH_NAME" | sed 's/[^a-zA-Z0-9-]/-/g' | sed 's/--*/-/g' | tr '[:upper:]' '[:lower:]' | sed 's/^-\|-$//g')
        
        # Truncate if too long (Azure Container Apps names must be <= 32 chars)
        if [ ${#SANITIZED_BRANCH} -gt 20 ]; then
          SANITIZED_BRANCH=$(echo "$SANITIZED_BRANCH" | cut -c1-20)
        fi
        
        # Set container app name based on branch
        if [[ "$BRANCH_NAME" == "main" || "$BRANCH_NAME" == "master" ]]; then
          CONTAINER_APP_NAME="aks-roadmap-viewer"
          CONTAINER_APP_ENV="aks-roadmap-env"
        else
          CONTAINER_APP_NAME="aks-roadmap-$SANITIZED_BRANCH"
          CONTAINER_APP_ENV="aks-roadmap-env-$SANITIZED_BRANCH"
        fi
        
        echo "BRANCH_NAME=$BRANCH_NAME" >> $GITHUB_OUTPUT
        echo "SANITIZED_BRANCH=$SANITIZED_BRANCH" >> $GITHUB_OUTPUT
        echo "CONTAINER_APP_NAME=$CONTAINER_APP_NAME" >> $GITHUB_OUTPUT
        echo "CONTAINER_APP_ENV=$CONTAINER_APP_ENV" >> $GITHUB_OUTPUT
        
        echo "Branch: $BRANCH_NAME"
        echo "Sanitized: $SANITIZED_BRANCH"
        echo "Container App: $CONTAINER_APP_NAME"
        echo "Environment: $CONTAINER_APP_ENV"

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=sha

    - name: Build and push Docker image
      uses: docker/build-push-action@v5
      with:
        context: .
        platforms: linux/amd64
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max

    - name: Azure Login
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}

    - name: Create Resource Group
      run: |
        az group create --name ${{ env.AZURE_RESOURCE_GROUP }} --location ${{ env.AZURE_LOCATION }} || true

    - name: Create Container Apps Environment
      run: |
        # Check if environment exists
        if ! az containerapp env show --name ${{ steps.branch-vars.outputs.CONTAINER_APP_ENV }} --resource-group ${{ env.AZURE_RESOURCE_GROUP }} &>/dev/null; then
          echo "Creating Container Apps environment with logging..."
          az containerapp env create \
            --name ${{ steps.branch-vars.outputs.CONTAINER_APP_ENV }} \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --location ${{ env.AZURE_LOCATION }} \
            --logs-workspace-id $(az monitor log-analytics workspace create \
              --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
              --workspace-name ${{ steps.branch-vars.outputs.CONTAINER_APP_ENV }}-logs \
              --location ${{ env.AZURE_LOCATION }} \
              --query customerId --output tsv) \
            --logs-workspace-key $(az monitor log-analytics workspace get-shared-keys \
              --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
              --workspace-name ${{ steps.branch-vars.outputs.CONTAINER_APP_ENV }}-logs \
              --query primarySharedKey --output tsv)
        else
          echo "Container Apps environment already exists"
        fi

    - name: Deploy to Azure Container Apps
      run: |
        # Get the image tag
        IMAGE_TAG=$(echo "${{ steps.meta.outputs.tags }}" | head -n1)

        # Check if container app exists
        if az containerapp show --name ${{ steps.branch-vars.outputs.CONTAINER_APP_NAME }} --resource-group ${{ env.AZURE_RESOURCE_GROUP }} &>/dev/null; then
          echo "Updating existing Container App with new revision..."

          # Update registry credentials first
          az containerapp registry set \
            --name ${{ steps.branch-vars.outputs.CONTAINER_APP_NAME }} \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --server ${{ env.REGISTRY }} \
            --username ${{ github.actor }} \
            --password ${{ secrets.GITHUB_TOKEN }}

          # Update the container app with new image and force restart
          az containerapp update \
            --name ${{ steps.branch-vars.outputs.CONTAINER_APP_NAME }} \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --image $IMAGE_TAG \
            --min-replicas 1 \
            --max-replicas 1 \
            --cpu 2.0 \
            --memory 4.0Gi \
            --set-env-vars \
              NODE_ENV=production \
              PORT=3000 \
              GITHUB_TOKEN="${{ secrets.GH_TOKEN }}" \
              AZURE_OPENAI_API_KEY="${{ secrets.AZURE_OPENAI_API_KEY }}" \
              AZURE_OPENAI_ENDPOINT="${{ secrets.AZURE_OPENAI_ENDPOINT }}" \
              AZURE_OPENAI_DEPLOYMENT_NAME="${{ secrets.AZURE_OPENAI_DEPLOYMENT_NAME }}"

          # Force restart to ensure new revision is active (single revision mode handles traffic automatically)
          echo "Forcing container restart to ensure new revision is active..."
          CURRENT_REVISION=$(az containerapp show --name ${{ steps.branch-vars.outputs.CONTAINER_APP_NAME }} --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --query properties.latestRevisionName --output tsv)
          echo "Current active revision: $CURRENT_REVISION"
          
          # In single revision mode, the latest revision automatically gets 100% traffic
          # We just need to ensure the app is properly restarted with the new image
          echo "Restarting container app to activate new revision..."
          az containerapp revision restart \
            --name ${{ steps.branch-vars.outputs.CONTAINER_APP_NAME }} \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --revision "$CURRENT_REVISION"
        else
          echo "Creating new Container App..."
          az containerapp create \
            --name ${{ steps.branch-vars.outputs.CONTAINER_APP_NAME }} \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --environment ${{ steps.branch-vars.outputs.CONTAINER_APP_ENV }} \
            --image $IMAGE_TAG \
            --registry-server ${{ env.REGISTRY }} \
            --registry-username ${{ github.actor }} \
            --registry-password ${{ secrets.GITHUB_TOKEN }} \
            --target-port 3000 \
            --ingress external \
            --min-replicas 1 \
            --max-replicas 1 \
            --cpu 2.0 \
            --memory 4.0Gi \
            --env-vars \
              NODE_ENV=production \
              PORT=3000 \
              GITHUB_TOKEN="${{ secrets.GH_TOKEN }}" \
              AZURE_OPENAI_API_KEY="${{ secrets.AZURE_OPENAI_API_KEY }}" \
              AZURE_OPENAI_ENDPOINT="${{ secrets.AZURE_OPENAI_ENDPOINT }}" \
              AZURE_OPENAI_DEPLOYMENT_NAME="${{ secrets.AZURE_OPENAI_DEPLOYMENT_NAME }}"
        fi

    - name: Get Container App Info
      id: container-app-info
      run: |
        FQDN=$(az containerapp show --name ${{ steps.branch-vars.outputs.CONTAINER_APP_NAME }} --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --query properties.configuration.ingress.fqdn --output tsv)
        echo "Container App deployed successfully!"
        echo "FQDN: $FQDN"
        echo "Access your app at: https://$FQDN"
        echo "fqdn=$FQDN" >> $GITHUB_OUTPUT

    - name: Show Container App Logs
      run: |
        echo "üìã Recent Container App logs:"
        az containerapp logs show \
          --name ${{ steps.branch-vars.outputs.CONTAINER_APP_NAME }} \
          --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
          --follow false \
          --tail 50 || echo "Could not retrieve logs (this is normal for new deployments)"

    - name: Test deployment
      run: |
        FQDN=${{ steps.container-app-info.outputs.fqdn }}
        echo "Testing deployment at https://$FQDN"

        # Wait for container to be ready
        sleep 30

        # Test health endpoint with 10s timeout
        timeout 10s bash -c "
        FQDN='${{ steps.container-app-info.outputs.fqdn }}'
        for i in {1..10}; do
          if curl -f \"https://\$FQDN/api/cache-info\"; then
            echo \"‚úÖ Deployment successful!\"
            echo \"üåê App URL: https://\$FQDN\"
            exit 0
          else
            echo \"‚è≥ Waiting for container to be ready... (attempt \$i/10)\"
            sleep 1
          fi
        done
        echo \"‚ùå Deployment test failed after 10 seconds\"
        exit 1
        "

    - name: Show Container App Logs After Test
      if: always()
      run: |
        echo "üìã Container App logs after test:"
        az containerapp logs show \
          --name ${{ steps.branch-vars.outputs.CONTAINER_APP_NAME }} \
          --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
          --follow false \
          --tail 100 || echo "Could not retrieve logs"

        echo "üìä Container App revision status:"
        az containerapp revision list \
          --name ${{ steps.branch-vars.outputs.CONTAINER_APP_NAME }} \
          --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
          --query '[].{Name:name,Active:properties.active,CreatedTime:properties.createdTime,Replicas:properties.replicas}' \
          --output table